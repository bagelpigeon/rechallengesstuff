
I joined RE CTFd to give myself a bit more of a concrete goal towards beginning reversing. I started with CMU's bomb diffusing challenge. The first challenge was pretty easy, even for a beginner. 2nd challenge was a pretty big spike-at least for me. What I found was really helpful was actually stepping through the first challenge's strings_not_equal function.</br>


This function calls another function that checks string length. This function is a fairly simple loop that compares each character in the string to a null byte. If not a null byte, eax gets incremented by 1. EAX ends up with the number of characters within the string. For me, I had to step through each and every single instruction and x/s or x/d each of the registers in the associated operation to understand what was going on. Given how some of the operations (dword ptr[esi + ebx*4-4]) confused me, I couldn't really tell what that value was until I actually ran the program. Still, just seeing how a simple loop worked in the the string length function helped give me a decent idea of what was going on in the 2nd challenge.</br>


The very first part of the 2nd challenge (when stepping through the read six numbers function) already has a bomb trigger. The bomb will explode if there are less than 6 numbers (separated by spaces).  This is seen within the function because the function sscanf is called with the string , and sscanf returns the number of successfully read arguments. (This is placed in eax) Then eax is compared to 5. The jump (which is wanted) will not happen and the bomb will explode if eax is not more than 5. Once through this, the next instruction inspects the first number that was typed. It is a fairly simple comparison, just checking if the first number is equal to 1. The key thing I've realized is that unlike functions in higher level languages, those registers stay forever. Placing a value into eax and the function calling ret won't change eax's value, so its been helpful for me to think - I don't know what's in eax, but there's a function above it so I can check what that function does and what it might be putting into eax.</br>


The second part goes into a loop depending on the previous number and the loop variable. So the next few numbers followed a pattern of previous number * (incremented loop variable + 2?) so 1*2 = 2, 2*3=6 and so on until all 6 numbers were revealed. This pattern can be revealed with brute forcing, just getting 1 first, and checking the eax register each time to see what the next number should be. In the cmp and imul operations, it was vital for me to check every single operand there and investigate what values were being compared or multiplied. It gave me a sense of what those instructions were actually pointing to and was probably the only reason why I realized it followed the above pattern.</br>


The third challenge is a switch. I found this one a bit easier than phase 2. Once again it checked for number of arguments. <3 means explosion. Looking at the format string, sscanf wanted an number, character, and number. I think there are multiple paths through this challenge, but I chose the 1 case. In this phase, it checks the first number, which determines the case (anything above 6 explodes the bomb because everything explodes the bomb), the next step it runs through is checking the 3rd argument (not the character, the other integer, this can be seen by referencing the variable name in the image). Three arguments are pushed onto the stack and the middle one must be a character. I simply just converted the hex to number to get the right number for the 1 case. Then the last check is for the character. This is also set up within the switch and I just converted the hex within the mov bl, hex operation to get the character.</br>


The fourth challenge looked simple when I first took a look at the nice graphs that the site sets up for you. The big part of this challenge is within func4, and the big thing this one introduces is recursion. The single argument you pass in appears to be decremented by one each time and compared. (For this I just kept checking the register that I knew my user controlled variable was in. However, the numbers that were being added together and returned didn't seem to depend directly on the user controlled variable. It seemed to depend on the number of times the function ran. since the cmp after func 4 returns is 55, I figured that the user variable would have to somehow force the function to return 55. Trying to see the recursive case and base case was pretty challenging. I noticed that there was always a jle x(your_user_arg) 1, so I assumed that was checking for the base case. I also kept tabs on the add operation which I thought would be the big thing that this function went off of and simply looked at the esi and eax registers that were being added together. At first I thought the function did something very simple, just decrementing and adding one to a sum. But I noticed that esi and eax had a familiar pattern, going from 2, 3, 5, 8, 13 and so on so I realized the recursive function was creating the fibonacci sequence.Since the user input determines the number of times the function recurses, this meant that I had to get the position of 55 in the fibonacci sequence, which turned out to be 9.</br>


The fifth challenge is looking like its asking for a string, and then altering it to get an expected string. It seems to shift the letters (0xf) and then shift it more using some values in an array. Will probably take a while for me to figure out exactly what its doing. In this case, it would probably be a good idea to make a small program to solve this if that is what its doing.</br>


