
I joined RE CTFd to give myself a bit more of a concrete goal towards beginning reversing. I started with CMU's bomb diffusing challenge. The first challenge was pretty easy, even for a beginner. 2nd challenge was a pretty big spike-at least for me. What I found was really helpful was actually stepping through the first challenge's strings_not_equal function.</br>


This function calls another function that checks string length. This function is a fairly simple loop that compares each character in the string to a null byte. If not a null byte, eax gets incremented by 1. EAX ends up with the number of characters within the string. For me, I had to step through each and every single instruction and x/s or x/d each of the registers in the associated operation to understand what was going on. Given how some of the operations (dword ptr[esi + ebx*4-4]) confused me, I couldn't really tell what that value was until I actually ran the program. Still, just seeing how a simple loop worked in the the string length function helped give me a decent idea of what was going on in the 2nd challenge.</br>


The very first part of the 2nd challenge (when stepping through the read six numbers function) already has a bomb trigger. The bomb will explode if there are less than 6 numbers (separated by spaces).  This is seen within the function because the function sscanf is called with the string , and sscanf returns the number of successfully read arguments. (This is placed in eax) Then eax is compared to 5. The jump (which is wanted) will not happen and the bomb will explode if eax is not more than 5. Once through this, the next instruction inspects the first number that was typed. It is a fairly simple comparison, just checking if the first number is equal to 1. The key thing I've realized is that unlike functions in higher level languages, those registers stay forever. Placing a value into eax and the function calling ret won't change eax's value, so its been helpful for me to think - I don't know what's in eax, but there's a function above it so I can check what that function does and what it might be putting into eax.</br>


The second part goes into a loop depending on the previous number and the loop variable. So the next few numbers followed a pattern of previous number * (incremented loop variable + 2?) so 1*2 = 2, 2*3=6 and so on until all 6 numbers were revealed. This pattern can be revealed with brute forcing, just getting 1 first, and checking the eax register each time to see what the next number should be. In the cmp and imul operations, it was vital for me to check every single operand there and investigate what values were being compared or multiplied. It gave me a sense of what those instructions were actually pointing to and was probably the only reason why I realized it followed the above pattern.</br>


The third challenge is a switch. I found this one a bit easier than phase 2. Once again it checked for number of arguments. <3 means explosion. Looking at the format string, sscanf wanted an number, character, and number. I think there are multiple paths through this challenge, but I chose the 1 case. In this phase, it checks the first number, which determines the case (anything above 6 explodes the bomb because everything explodes the bomb), the next step it runs through is checking the 3rd argument (not the character, the other integer, this can be seen by referencing the variable name in the image). Three arguments are pushed onto the stack and the middle one must be a character. I simply just converted the hex to number to get the right number for the 1 case. Then the last check is for the character. This is also set up within the switch and I just converted the hex within the mov bl, hex operation to get the character.</br>


The fourth challenge looked simple when I first took a look at the nice graphs that the site sets up for you. The big part of this challenge is within func4, and the big thing this one introduces is recursion. The single argument you pass in appears to be decremented by one each time and compared. (For this I just kept checking the register that I knew my user controlled variable was in. However, the numbers that were being added together and returned didn't seem to depend directly on the user controlled variable. It seemed to depend on the number of times the function ran. since the cmp after func 4 returns is 55, I figured that the user variable would have to somehow force the function to return 55. Trying to see the recursive case and base case was pretty challenging. I noticed that there was always a jle x(your_user_arg) 1, so I assumed that was checking for the base case. I also kept tabs on the add operation which I thought would be the big thing that this function went off of and simply looked at the esi and eax registers that were being added together. At first I thought the function did something very simple, just decrementing and adding one to a sum. But I noticed that esi and eax had a familiar pattern, going from 2, 3, 5, 8, 13 and so on so I realized the recursive function was creating the fibonacci sequence.Since the user input determines the number of times the function recurses, this meant that I had to get the position of 55 in the fibonacci sequence, which turned out to be 9.</br>


The fifth challenge asks for a string, and uses it to get an expected string. Each character gets anded with (0xf). Initially I thought the array would alter the input string to get the expected string, but after running through with gdb, it seems that after the initial and operation, it then uses the value to get the index of one of the characters in the array, which will return the final output. I made a python script(same directory) that does this two ways. The first way is to create the anded values of all the characters in the alphabet. 
Then after getting the indices of the goal string from the scrambled string, just find the right character depending on their values. The second way is using a cesar cipher decryption method where the formula is (indices - 33) % 16. At the moment I am unsure if the second way works in all cases. This was formed by nothing that after anding every single letter of the alphabet, the letters of the alphabet would start at 1, 2, 3...15, then the cycle begins again at 0. </br>

Phase 6 is far longer. It was not manageable to go through the entire thing like some of the other phases. I ended up looking for things that checked user input first (as well as what it seemed to be looking for in the final output. Looking at the first nested loop, it looked like it was making sure that each user input was not equal to the other user inputs, so all 6 numbers have to be different. In addition, the first instruction of the loop is to compare a decremented number of the user input to 5. If the decremented number is greater than 5 it explodes, which means that the number can't be bigger than 6. Looking at the last loop, it seems to be comparing one node to another node and checking if its value is greater than the other before moving to the next node. If the value is less than (or at least out of order), the bomb will explode. Looking at the nested loop right after the "each number must be unique" part, seems to show that inner loop is looking for a node based on the user input value. It moves the pointer forward by putting esi+8 into esi, while incrementing a counter and comparing it to the user input number. Since the final loop seems to be checking order, somehow the user input must rearrange the nodes, which is probably what the outer loop does. After finding the particular node referenced by the user input, it seems to put that address into some incrementing offset of var_40. So on one of the runthroughs, with the order 5 4 3 2 1 6, node 5 was placed into this var_40 variable and it is assumed that 4 would be placed after 5 because of the incrementing offset, which means that the user input likely determines the order of the nodes. The last step is to find which nodes have what values and to figure out the correct number order so that they are in descending order. ESI gets compared to ESI+8 and ESI's value must be greater than ESI+8's value to avoid bomb explosion.
